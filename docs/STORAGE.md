# Хранение и синхронизация цепочки Kolibri

Kolibri ведёт журнал шагов в файле `logs/chain.jsonl`. Каждый шаг сериализуется как одна строка JSON (формат JSONL). Блок содержит:

| Поле | Описание |
| --- | --- |
| `step`, `parent`, `seed` | Номер шага, ссылка на предыдущий и исходное зерно генератора. |
| `config_fingerprint` | SHA-256 канонического конфига, идентификатор конфигурации. |
| `origin_node` | Узел, на котором блок был создан. Для локальных шагов равен `node_id` из конфигурации. |
| `fmt`, `formula`, `param_count`, `params[]` | Формула и параметры, сгенерированные на шаге. |
| `eff`, `compl` | Метрики эффективности и сложности. |
| `prev`, `hash`, `hmac` | Связность и контроль целостности. `hash` — SHA-256 полезной нагрузки; `hmac` — HMAC-SHA256 по секретному ключу. |
| `votes[]`, `vote_softmax`, `vote_median` | Аггрегированные голоса цифр. |
| `bench[]`, `memory`, `merkle`, `fa`, `fa_map`, `fa_stab`, `r` | Диагностика и трекинг фрактального адреса. |

Хэш и HMAC вычисляются из канонической полезной нагрузки функцией `rb_payload_json`. Проверка выполняется как утилитой `backend/src/main_verify.c`, так и скриптом `tools/chain_verify.js`.

## Сетевой обмен

Сервис синхронизации (`backend/src/sync.c`) открывает TCP-порт, указанный в `sync_listen_port`. Протокол `SYNC/1`:

1. Клиент отправляет:
   ```
   SYNC/1
   NODE <node_id>
   FP <fingerprint>
   HEIGHT <height>
   HASH <head_hash>
   REQUEST <start_step>
   TRUST <ratio>
   END
   ```
   `start_step` обычно равен последнему локальному шагу + 1.
2. Сервер отвечает:
   ```
   SYNC/1
   STATUS <ok|foreign>
   NODE <server_node>
   FP <fingerprint>
   HEIGHT <height>
   HASH <head_hash>
   BLOCK <step> <len>\n<payload>
   ...
   END
   ```
   Для каждого недостающего блока передаётся пара строк `BLOCK …` + JSON-полезная нагрузка.

## Доверие и конфликты

* Если отпечаток конфига (`fingerprint`) совпадает и цепочка строго продолжается, блоки проверяются локально (повторная генерация payload → сравнение `hash` и `hmac`) и добавляются функцией `chain_append`.
* При несовпадении отпечатков данные считаются «чужими» и помещаются в `logs/foreign/<node>.jsonl` без включения в основную цепь.
* Если отпечатки равны, но связь по `prev`/`hash` рвётся, блоки считаются конфликтными. Они сохраняются в `logs/conflicts/<node>.jsonl` для ручного анализа.

Каждый синхронизированный блок сохраняет оригинальное поле `origin_node`, благодаря чему можно отследить источник даже после повторной записи.

## Ограничения

- Формат журналов append-only: допустимы только добавления в конец.
- Синхронизация не выполняет автоматическое слияние конфликтующих ветвей, только сохраняет их для обзора.
- Для репликации требуется общий HMAC-ключ (`KOLIBRI_HMAC_KEY` или значение в конфиге), иначе проверка подписи провалится.

## Проверка знаний и журналирование

Kolibri сохраняет факты в графе знаний `KnowledgeGraph`. Для автоматической проверки используются «критики» — функции, которые
возвращают оценку доверия к каждому узлу. Список критиков можно задать в конфигурации (например, в `configs/kolibri.json`):

```json
{
  "knowledge_graph": {
    "critics": {
      "confidence_gate": {"type": "confidence_threshold", "threshold": 0.7},
      "security_keywords": {"type": "keyword_presence", "keywords": ["secure", "safety"]}
    }
  }
}
```

Граф загружает критиков при создании и кеширует результаты проверки, пока структура графа не изменится. Это позволяет повторно
использовать оценки при повторных проверках без повторного вызова всех функций.

CLI-команда `python -m kolibri_x.cli.verify` запускает ручную проверку. Параметр `--knowledge PATH` предварительно загружает
документы, а флаг `--json` выводит подробный отчёт. При успешной проверке в `ActionJournal` добавляются события `knowledge_ingest`
и `knowledge_verification`: первое фиксирует количество узлов/рёбер и предупреждения, второе — найденные конфликты и положительные
«пруфы» (узлы, набравшие высокий балл). Результаты можно просмотреть командой `:journal` в интерактивном чате или через API
журнала.
