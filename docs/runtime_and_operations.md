# Эксплуатация и рантайм

> Ведущий: Кочуров Владислав Евгеньевич. Любые изменения рантайма,
> конфигураций или процедур сопровождения фиксируйте здесь.

## Подготовка окружения

1. Соберите бэкенд (`make bin/kolibri_run` или `./build_macos.sh bin/kolibri_run`).
2. Убедитесь, что переменная `KOLIBRI_HMAC_KEY` установлена, если требуются
   HMAC-подписи. Без неё журнал содержит только `hash`.
3. Очистите предыдущие логи командой `make clean` (по необходимости).

## Конфигурация

Основной файл — `configs/kolibri.json`:

```json
{
  "steps": 32,
  "depth_max": 3,
  "depth_decay": 0.7,
  "quorum": 0.6,
  "temperature": 0.15,
  "eff_threshold": 0.8,
  "max_complexity": 32.0,
  "seed": 987654321
}
```

- Увеличение `steps` и `depth_max` повышает качество поиска, но увеличивает
  время выполнения. На текущей ревизии ядра глубина 3 и 32 шага дают прирост
  эффективности (≈0.72 на 28–30 шаге при разумной сложности формул) по сравнению
  с прежними значениями (30/2).
- `quorum` и `eff_threshold` защищают от слабых кандидатов.
- `seed` обеспечивает воспроизводимость между запусками.

## Запуск сессии

```bash
./bin/kolibri_run configs/kolibri.json
```

- В каталоге `logs/` появится `chain.jsonl`. Каждая строка — один шаг,
  сериализованный каноническим JSON (без пробелов, числа формата `%.17g`).
- При запуске с `KOLIBRI_HMAC_KEY` каждая запись содержит `hmac`.
- Логи дополняются, поэтому при повторном прогоне удалите файл или
  выполните `make clean`.

## Проверка и воспроизведение

```bash
./bin/kolibri_verify logs/chain.jsonl
./bin/kolibri_replay configs/kolibri.json logs/chain.jsonl
```

- `kolibri_verify` считывает записи, пересчитывает `hash`/`hmac` и сообщает о
  несоответствиях.
- `kolibri_replay` восстанавливает вычислительные шаги по журналу, полезно
  для отладки и регрессионных прогонов.
- `tools/profile_cli.py` замеряет `kolibri_run`/`verify`/`replay` и сохраняет
  JSON-отчёт в `logs/cli_profiles/`, что удобно для сравнения оборудования.

## Мониторинг и журналы

| Файл | Описание |
| --- | --- |
| `logs/chain.jsonl` | Основной журнал выполнения. |
| `logs/*.json` | Побочные артефакты (например, дампы планов), создаются при включённых отладочных флагах. |

В продакшн-сценариях храните журналы в неизменяемом хранилище и
используйте `kolibri_verify` как часть CI.

## Работа с KolibriRuntime

Для интеграции Python-компонентов используйте `KolibriRuntime`:

-```python
from kolibri_x.runtime.orchestrator import KolibriRuntime, RuntimeRequest
from kolibri_x.runtime.orchestrator import SkillSandbox

sandbox = SkillSandbox()
sandbox.register("echo", lambda payload: {"text": payload["goal"].upper()})

runtime = KolibriRuntime(sandbox=sandbox)
runtime.privacy.grant("demo", ["text"])
response = runtime.process(
    RuntimeRequest(user_id="demo", goal="echo", modalities={"text": "hello"})
)
print(response.answer["summary"])
```

- Конфигурация runtime описана в [architecture](architecture.md).
- Все внешние навыки должны регистрироваться в `SkillStore` или напрямую в
  `SkillSandbox` (для тестов). Перед первым запросом выдавайте пользователю
  разрешения на необходимые модальности через `runtime.privacy.grant`.

### Консольный чат

1. Активируйте Python-окружение с установленным пакетом `kolibri_x`
   (например, `pip install -e .`).
2. Запустите CLI, указав идентификатор пользователя, которому нужно выдать
   доступ к текстовой модальности:

   ```bash
   python -m kolibri_x.cli.chat --user-id demo
   ```

3. При необходимости передайте аргумент `--knowledge`, чтобы сразу загрузить
   документы в граф знаний до начала диалога. CLI принимает как путь к файлу,
   так и директорию:

   ```bash
   python -m kolibri_x.cli.chat --user-id demo --knowledge docs/primer.txt
   ```

4. После запуска введите сообщение — runtime сформирует план, выполнит
   sandbox-навык по умолчанию и покажет суммарный ответ. Доступны специальные
   команды:

   - `:journal` — вывести последние события `ActionJournal`.
   - `:reason` — распечатать `ReasoningLog` текущего ответа в формате JSON.
   - `:quit` — завершить сессию.

   Все команды работают в одном цикле, поэтому можно чередовать пользовательские
   сообщения и отладочные запросы.

По умолчанию CLI регистрирует sandbox-навык `chat_responder` без дополнительных
разрешений. При необходимости замените обработчик в `kolibri_x/cli/chat.py`,
чтобы перенаправлять запросы в собственные навыки или внешние сервисы.

### Ограничения песочницы и квоты

- Каждая запись манифеста навыка должна описывать секцию `limits`.
  Значения автоматически приводятся к целым числам и попадают в структуру
  `SkillQuota`. Доступны поля:
  - `invocations` — максимально допустимое количество запусков за сессию
    рантайма.
  - `cpu_ms`/`wall_ms` — суммарное процессорное/реальное время в миллисекундах,
    накопленное `SkillSandbox` по результатам таймера.
  - `net_bytes`/`fs_bytes`/`fs_ops` — счётчики сетевого и файлового I/O
    (значения увеличиваются вручную через `SkillSandbox.record_io`).
  - дополнительные ключи сохраняются в `SkillQuota.extra` и доступны для
    сторонних ограничителей.
- Перед каждым вызовом песочница проверяет накопленные значения. Если квота
  исчерпана, поднимается `SkillQuotaExceeded`, выполнение шага блокируется, а в
  `ActionJournal` записывается событие `skill_quota_blocked` с полями
  `skill`, `resource`, `limit`, `used`, `step_id` и `user_id`.
- После успешного запуска `SkillSandbox` обновляет таймеры CPU и wall clock,
  чтобы следующий вызов учитывал уже затраченные ресурсы. При необходимости
  увеличивайте счётчики сетевых/файловых операций из собственного кода:

```python
runtime.sandbox.record_io("kit.iot.thermostat", net_bytes=2048, fs_ops=1)
```

- Отсутствие поля `limits` приравнивается к неограниченному навыку. Для
  ограничения только части ресурсов указывайте интересующие ключи, остальные
  будут проигнорированы.

## Офлайн-режим

- `OfflineCache` хранит запросы и планы на диске. При восстановлении сети
  запускается синхронизация с KG и журналом.
- При разработке офлайн-логики логируйте операции через `ActionJournal` и
  обновляйте описание в этом документе.

## Оповещения и SLA

- По умолчанию платформа работает локально. Подключение телеметрии должно
  документироваться отдельно.
- SLA измеряются метриками mKSI и успешностью верификации журналов. См.
  [roadmap](roadmap.md) для целевых значений.

