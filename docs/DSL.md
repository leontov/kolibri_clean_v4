# Kolibri DSL

Kolibri использует компактный язык выражений, представленный в виде деревьев. Каждый узел дерева принадлежит к одному из типов:

- `CONST` — числовая константа (double).
- `VAR_X` — переменная входа `x`.
- `ADD`, `SUB`, `MUL`, `DIV` — бинарные арифметические операции.
- `SIN`, `COS`, `TANH`, `EXP`, `LOG`, `ABS` — унарные функции.
- `CLAMP` — ограничение значения в диапазоне `[min, max]`.
- `IFZ` — тернарный узел: если `|cond| < ε`, вернуть `whenZero`, иначе `whenElse`.

## Правила построения

1. Максимальная глубина дерева по умолчанию — 4.
2. Деление защищено: при `|denom| < 1e-9` возвращается 0.
3. `LOG` работает только для положительных значений; иначе возвращается 0.
4. Для `CLAMP`, если `min > max`, они меняются местами.

## Представление формулы

Функция `dsl_print` выводит выражение в префиксной форме S-выражений, например:

```
(mul (sin x) (add 0.5 x))
```

Строковое представление однозначно соответствует структуре дерева и используется для сериализации в цепочку блоков.

## Мутации и упрощения

- `dsl_rand` создаёт случайное дерево ограниченной глубины.
- `dsl_mutate` клонирует формулу и заменяет случайный узел новым поддеревом или варьирует константу.
- `dsl_simplify` выполняет свёртку констант и устраняет очевидные комбинации.

## Оценка

`dsl_eval` вычисляет значение выражения при заданном `x` и является основой для подсчёта метрик.

## Сценарии использования

### Быстрый прогон с исходными данными

1. Сформируйте набор наблюдений. Простейший способ — запустить `kolibri_native`
   с параметром `--no-bootstrap`, чтобы фрактал начал с генерации случайных
   формул и автоматически записал цепочку блоков.
2. Найдите в хвосте журнала формулу, которая показала достаточное значение
   `eff`. Например, запись

   ```
   (ifz (clamp (clamp 0.003 x -0.857) (abs -0.343) (mul 0.947 -0.053))
        (abs (log x))
        (clamp (log 0.602) (cos 0.013) (ifz 0.256 0.346 x)))
   ```

   представляет условное ветвление: при малой разнице между `x` и `0.857`
   выбирается верхняя ветка `abs (log x)`, иначе выражение переключается на
   ограниченный диапазон `clamp`.
3. Подайте формулу обратно через `dsl_eval`, чтобы воспроизвести выход. Это
   можно сделать либо напрямую в ядре (например, сохранив указатель на текущую
   формулу из `KolEngine`), либо через собственную FFI-обвязку: пройдитесь по
   сетке значений `x`, вызовите `dsl_eval` и сохраните результаты в таблицу.
   Полученные значения удобно сравнить с эталонной функцией или добавить в
   отчёт по эксперименту.

### Миксование модальностей

1. Преобразуйте сенсорные данные в последовательность цифр `0–9` функциями
   `kol_ingest_digits`, `kol_ingest_bytes` или `kol_ingest_signal`.
2. Сформированный `KolEvent` объединяется с текстовыми токенами — DSL видит
   единый набор наблюдений и может комбинировать их в одной формуле.
3. После шага `kol_tick` вызовите `kol_emit_digits` и `kol_emit_text`, чтобы
   получить синтетические данные в обеих модальностях. Формула, занесённая в
   журнал, отражает логику смешения.

### Ручное тестирование мутаций

1. Сгенерируйте базовую формулу `dsl_rand(&seed, depth)` и оцените её на
   датасете `engine->dataset`.
2. Для локальных изменений вызовите `dsl_mutate` с тем же генератором
   случайных чисел. Это создаст копию дерева с заменой одного из узлов.
3. Сравните `dsl_eval` исходной и мутированной формулы. Если изменение даёт
   прирост метрик, передайте результат в `digit_learn`, чтобы зафиксировать
   обновление в опыте цифры.

Эти сценарии помогают быстро отлаживать новые узлы DSL, проверять влияние
изменений параметров и демонстрировать цепочку преобразований пользователям.
